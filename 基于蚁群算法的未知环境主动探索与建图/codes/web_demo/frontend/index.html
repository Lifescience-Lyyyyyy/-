<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŸºäºèšç¾¤ç®—æ³•çš„ä¸»åŠ¨å»ºå›¾æ¼”ç¤º</title>
    <style>
        :root { --primary-color: #007bff; --secondary-color: #6c757d; --bg-color: #f8f9fa; --header-bg: #343a40; --sidebar-bg: #ffffff; --text-color: #212529; --light-gray: #dee2e6; --danger-color: #dc3545; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; background-color: var(--bg-color); display: flex; flex-direction: column; height: 100vh; color: var(--text-color); }
        .hidden { display: none !important; }
        header { background-color: var(--header-bg); color: white; padding: 1rem 2rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 1.5rem; }
        .container { display: flex; flex: 1; overflow: hidden; }
        .sidebar { width: 400px; background-color: var(--sidebar-bg); padding: 1.5rem; overflow-y: auto; border-right: 1px solid var(--light-gray); display: flex; flex-direction: column; flex-shrink: 0; }
        
        .main-content { flex: 1; padding: 1.5rem; display: flex; flex-direction: row; overflow: hidden; gap: 1.5rem; }
        
        .tab-content { display: flex; flex-direction: column; min-width: 0; }
        #visualizer-tab { flex: 2 1 65%; } 
        #explanation-tab { flex: 1 1 35%; } 

        .visualizer-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #e9ecef; border-radius: 8px; padding: 1rem; }
        canvas { background-color: white; border: 1px solid #ccc; max-width: 100%; max-height: 100%; object-fit: contain; }
        h2 { color: var(--header-bg); border-bottom: 2px solid var(--primary-color); padding-bottom: 0.5rem; margin-top: 0; }
        h3,h4 { color: var(--header-bg); margin-top: 1.5rem; }
        .param-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        input, select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        button { background-color: var(--primary-color); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 1rem; width: 100%; transition: background-color 0.2s; margin-top: 10px; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; }
        .stat-card { background-color: white; padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--light-gray); }
        .stat-card .label { font-size: 0.9rem; color: #555; }
        .stat-card .value { font-size: 1.5rem; font-weight: bold; color: var(--header-bg); }
        .value.error { color: var(--danger-color); }
        #drawing-canvas { border: 1px dashed var(--secondary-color); cursor: crosshair; margin-bottom: 10px; }
        .draw-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        #explanation-tab { overflow-y: auto; background-color: #fff; border: 1px solid var(--light-gray); border-radius: 8px; padding: 1.5rem; }
        #explanation-tab p { line-height: 1.6; }
        #explanation-tab code { background-color: #e9ecef; padding: 2px 6px; border-radius: 4px; font-family: "Courier New", Courier, monospace; }
        #explanation-tab h4 { color: var(--primary-color); margin-top: 1rem; margin-bottom: 0.5rem;}
    </style>
</head>
<body>
    <header><h1>åŸºäºèšç¾¤ç®—æ³•çš„ä¸»åŠ¨å»ºå›¾æ¼”ç¤º</h1></header>
    <div class="container">
        <aside class="sidebar">
             <h2>âš™ï¸ é…ç½®</h2>
            <div class="param-group"><label for="mode-switch">é€‰æ‹©æ¨¡å¼:</label><select id="mode-switch"><option value="path_planning">è·¯å¾„è§„åˆ’ (å·²çŸ¥åœ°å›¾)</option><option value="exploration">è‡ªä¸»æ„å›¾ (æœªçŸ¥ç¯å¢ƒ)</option></select></div>
            <div id="map-creation-panel">
                <h3>ğŸ—ºï¸ åœ°å›¾åˆ›å»º</h3>
                <div class="param-group"><label for="map-source">åœ°å›¾æ¥æº:</label><select id="map-source"><option value="generate">ç¨‹åºç”Ÿæˆ</option><option value="draw">æ‰‹ç»˜åœ°å›¾</option></select></div>
                <div id="generate-map-panel">
                    <div class="param-group"><label for="map-width">åœ°å›¾å®½åº¦: <span id="map-width-val">40</span></label><input type="range" id="map-width" min="20" max="80" value="40"></div>
                    <div class="param-group"><label for="map-height">åœ°å›¾é«˜åº¦: <span id="map-height-val">30</span></label><input type="range" id="map-height" min="20" max="60" value="30"></div>
                    <div class="param-group"><label for="map-type">ç”Ÿæˆç±»å‹:</label><select id="map-type"><option value="random">éšæœº</option><option value="deceptive_hallway">æ¬ºéª—æ€§èµ°å»Š</option></select></div>
                    <div class="param-group" id="obstacle-perc-group"><label for="obstacle-perc">éšœç¢ç‰©æ¯”ä¾‹: <span id="obstacle-perc-val">0.25</span></label><input type="range" id="obstacle-perc" min="0.0" max="0.5" value="0.15" step="0.01"></div>
                    <button id="generate-map-btn">ç”Ÿæˆæ–°åœ°å›¾</button>
                </div>
                <div id="draw-map-panel" class="hidden">
                    <p style="font-size: 0.8em; color: #555; text-align: center;">æŒ‰ä½é¼ æ ‡ç»˜åˆ¶éšœç¢ï¼ŒShift+é¼ æ ‡æ¸…é™¤ã€‚</p>
                    <canvas id="drawing-canvas"></canvas>
                    <div class="draw-buttons">
                        <button id="clear-canvas-btn" style="background-color: var(--secondary-color);">æ¸…ç©ºç”»å¸ƒ</button>
                        <button id="confirm-draw-btn">åº”ç”¨æ­¤åœ°å›¾</button>
                    </div>
                </div>
            </div>
            <div id="params-panel">
                <h3>ğŸœ ç®—æ³•å‚æ•°</h3>
                <div id="path-planning-params">
                    <div class="param-group"><label for="n-ants-pp">èš‚èšæ•°é‡: <span id="n-ants-pp-val">20</span></label><input type="range" id="n-ants-pp" min="5" max="100" value="20"></div>
                    <div class="param-group"><label for="n-iterations-pp">è¿­ä»£æ¬¡æ•°: <span id="n-iterations-pp-val">120</span></label><input type="range" id="n-iterations-pp" min="10" max="200" value="120"></div>
                </div>
                <div id="exploration-params" class="hidden">
                    <div class="param-group"><label for="sensor-range">æœºå™¨äººä¼ æ„Ÿå™¨èŒƒå›´: <span id="sensor-range-val">5</span></label><input type="range" id="sensor-range" min="2" max="15" value="5"></div>
                </div>
                <div class="param-group"><label for="alpha">Alpha (ä¿¡æ¯ç´ å½±å“): <span id="alpha-val">1.0</span></label><input type="range" id="alpha" min="0.0" max="5.0" value="1.0" step="0.1"></div>
                <div class="param-group"><label for="beta">Beta (å¯å‘å¼å½±å“): <span id="beta-val">2.5</span></label><input type="range" id="beta" min="0.0" max="10.0" value="2.5" step="0.1"></div>
                <div class="param-group"><label for="evaporation">ä¿¡æ¯ç´ è’¸å‘ç‡: <span id="evaporation-val">0.3</span></label><input type="range" id="evaporation" min="0.0" max="1.0" value="0.3" step="0.01"></div>
                <div class="param-group"><label for="use-elitist"><input type="checkbox" id="use-elitist" checked> ä½¿ç”¨ç²¾è‹±èš‚èšç³»ç»Ÿ (ä»…è·¯å¾„è§„åˆ’)</label></div>
            </div>
            <button id="run-simulation-btn" disabled>â–¶ï¸ è¿è¡Œæ¨¡æ‹Ÿ</button>
        </aside>
        <main class="main-content">
            <div id="visualizer-tab" class="tab-content">
                <div class="visualizer-container" id="visualizer-container"><canvas id="main-canvas"></canvas></div>
                <div class="stats">
                    <div class="stat-card"><div class="label" id="stat1-label">æ¨¡æ‹ŸçŠ¶æ€</div><div id="status-text" class="value">æ­£åœ¨è¿æ¥æœåŠ¡å™¨...</div></div>
                    <div class="stat-card"><div class="label" id="stat2-label">è·¯å¾„é•¿åº¦ / è¿›åº¦</div><div id="info-text" class="value">N/A</div></div>
                </div>
            </div>
            <div id="explanation-tab" class="tab-content">
                <h2>ç®—æ³•ä¸å‚æ•°è¯¦è§£</h2>
                <h3>æ ¸å¿ƒç®—æ³•</h3>
                <p>æœ¬é¡¹ç›®æ¼”ç¤ºäº†ä¸¤ç§åŸºäºèšç¾¤ä¼˜åŒ–(Ant Colony Optimization, ACO)çš„ç®—æ³•ï¼š</p>
                <ul>
                    <li><strong>è·¯å¾„è§„åˆ’ (Path Planning):</strong> åœ¨ä¸€ä¸ªå®Œå…¨å·²çŸ¥çš„åœ°å›¾ä¸Šï¼Œåˆ©ç”¨ACOå¯»æ‰¾ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€ä¼˜è·¯å¾„ã€‚</li>
                    <li><strong>è‡ªä¸»æ„å›¾ (Exploration):</strong> æ¨¡æ‹Ÿä¸€ä¸ªæœºå™¨äººåœ¨æœªçŸ¥ç¯å¢ƒä¸­ï¼Œåˆ©ç”¨ä¼ æ„Ÿå™¨å’Œä¸€ç§åŸºäºACOçš„æ¢ç´¢ç­–ç•¥æ¥é€æ­¥æ„å»ºåœ°å›¾ã€‚</li>
                </ul>
                <h3>é€šç”¨å‚æ•° (ACOæ ¸å¿ƒ)</h3>
                <p>è¿™äº›å‚æ•°åŒæ—¶å½±å“è·¯å¾„è§„åˆ’å’Œè‡ªä¸»æ„å›¾ä¸­çš„èš‚èšè¡Œä¸ºã€‚</p>
                <h4>Alpha (ä¿¡æ¯ç´ å½±å“å› å­)</h4>
                <p>æ§åˆ¶äº†è·¯å¾„ä¸Šå·²å­˜åœ¨çš„ä¿¡æ¯ç´ å¯¹èš‚èšå†³ç­–çš„å½±å“ç¨‹åº¦ã€‚<code>Alpha</code> å€¼è¶Šé«˜ï¼Œèš‚èšè¶Šå€¾å‘äºè·Ÿéšä¹‹å‰èš‚èšèµ°è¿‡çš„ã€ä¿¡æ¯ç´ æµ“åº¦é«˜çš„è·¯å¾„ã€‚è¿™ä¼šåŠ é€Ÿæ”¶æ•›ï¼Œä½†ä¹Ÿå¯èƒ½è¿‡æ—©åœ°é™·å…¥å±€éƒ¨æœ€ä¼˜è§£ã€‚</p>
                <h4>Beta (å¯å‘å¼å½±å“å› å­)</h4>
                <p>æ§åˆ¶äº†å¯å‘å¼ä¿¡æ¯ï¼ˆå³é¢„å…ˆè®¡ç®—çš„ã€é€šå¾€ç›®æ ‡æœ‰å¤šâ€œåˆ’ç®—â€çš„ä¿¡æ¯ï¼‰å¯¹èš‚èšå†³ç­–çš„å½±å“ã€‚
                    <ul>
                       <li>åœ¨<strong>è·¯å¾„è§„åˆ’</strong>ä¸­ï¼Œå¯å‘ä¿¡æ¯æ˜¯å½“å‰ç‚¹åˆ°ç»ˆç‚¹çš„ç›´çº¿è·ç¦»çš„å€’æ•°ã€‚<code>Beta</code> è¶Šé«˜ï¼Œèš‚èšè¶Šå€¾å‘äºæœå‘ç»ˆç‚¹ç›´çº¿å‰è¿›ï¼Œæ˜¯ä¸€ç§è´ªå¿ƒç­–ç•¥ã€‚</li>
                       <li>åœ¨<strong>è‡ªä¸»æ„å›¾</strong>ä¸­ï¼Œå¯å‘ä¿¡æ¯æ˜¯å‰å¾€æœªçŸ¥åŒºåŸŸï¼ˆFrontierï¼‰çš„â€œå¥–åŠ±â€ï¼Œè·ç¦»æœºå™¨äººè¶Šè¿‘çš„è¾¹ç•Œç‚¹ï¼Œå¯å‘å€¼è¶Šé«˜ã€‚<code>Beta</code> è¶Šé«˜ï¼Œæœºå™¨äººè¶Šæœ‰åŠ¨åŠ›å»æ¢ç´¢æœ€è¿‘çš„æœªçŸ¥è¾¹ç•Œã€‚</li>
                    </ul>
                </p>
                <h4>ä¿¡æ¯ç´ è’¸å‘ç‡ (Evaporation Rate)</h4>
                <p>æ¨¡æ‹Ÿäº†çœŸå®ä¸–ç•Œä¸­ä¿¡æ¯ç´ éšæ—¶é—´è’¸å‘çš„ç°è±¡ã€‚æ¯ä¸€è½®è¿­ä»£åï¼Œåœ°å›¾ä¸Šæ‰€æœ‰ä¿¡æ¯ç´ éƒ½ä¼šä¹˜ä»¥ <code>(1.0 - evaporation_rate)</code>ã€‚è¿™æœ‰åŠ©äºé¿å…ç®—æ³•è¿‡æ—©åœæ»ï¼Œå…è®¸èš‚èšæ¢ç´¢æ–°çš„è·¯å¾„ã€‚ä¸€ä¸ªè¾ƒé«˜çš„è’¸å‘ç‡æ„å‘³ç€â€œé—å¿˜â€å¾—æ›´å¿«ï¼Œæœ‰åˆ©äºæ¢ç´¢ï¼›è¾ƒä½çš„è’¸å‘ç‡åˆ™æœ‰åˆ©äºåŠ å¼ºæœ€ä¼˜è·¯å¾„ã€‚</p>

                <h3>è·¯å¾„è§„åˆ’æ¨¡å¼ç‰¹å®šå‚æ•°</h3>
                <h4>èš‚èšæ•°é‡ (n_ants_pp)</h4>
                <p>æ¯ä¸€è½®è¿­ä»£ä¸­é‡Šæ”¾çš„èš‚èšæ€»æ•°ã€‚æ›´å¤šçš„èš‚èšå¯ä»¥æ›´å…¨é¢åœ°æ¢ç´¢åœ°å›¾ï¼Œä½†ä¼šå¢åŠ è®¡ç®—å¼€é”€ã€‚</p>
                
                <h4>è¿­ä»£æ¬¡æ•° (n_iterations_pp)</h4>
                <p>ç®—æ³•è¿è¡Œçš„æ€»è½®æ•°ã€‚æ›´å¤šçš„è¿­ä»£æ¬¡æ•°ç»™äºˆç®—æ³•æ›´å¤šæ—¶é—´æ¥ä¼˜åŒ–å’Œæ”¶æ•›åˆ°æœ€ä¼˜è·¯å¾„ã€‚</p>
                
                <h4>ç²¾è‹±èš‚èšç³»ç»Ÿ (Elitist Ant System)</h4>
                <p>å¦‚æœå¯ç”¨ï¼Œæ¯ä¸€è½®è¿­ä»£åï¼Œä¼šç»™å½“å‰æ‰¾åˆ°çš„â€œå…¨å±€æœ€ä¼˜è·¯å¾„â€ä¸€ä¸ªé¢å¤–çš„ã€æƒé‡æ›´é«˜çš„ä¿¡æ¯ç´ å¥–åŠ±ã€‚è¿™æå¤§åœ°åŠ å¿«äº†æ”¶æ•›é€Ÿåº¦ï¼Œèƒ½æ›´å¿«åœ°æ‰¾åˆ°é«˜è´¨é‡çš„è§£ã€‚</p>
                
                <h3>è‡ªä¸»æ„å›¾æ¨¡å¼ç‰¹å®šå‚æ•°</h3>
                <h4>æœºå™¨äººä¼ æ„Ÿå™¨èŒƒå›´ (sensor_range)</h4>
                <p>æœºå™¨äººèƒ½â€œçœ‹â€å¤šè¿œã€‚å®ƒå†³å®šäº†æœºå™¨äººæ¯æ¬¡ç§»åŠ¨åèƒ½å°†å¤šå¤§èŒƒå›´çš„æœªçŸ¥åŒºåŸŸï¼ˆ`UNKNOWN`ï¼‰å˜ä¸ºå·²çŸ¥åŒºåŸŸï¼ˆ`FREE` æˆ– `OBSTACLE`ï¼‰ã€‚</p>
                <p><strong>æ³¨æ„: </strong>åœ¨è‡ªä¸»æ„å›¾æ¨¡å¼ä¸‹ï¼Œä¾§è¾¹æ ä¸­çš„â€œèš‚èšæ•°é‡â€å’Œâ€œè¿­ä»£æ¬¡æ•°â€å‚æ•°**ä¸ä¼šè¢«ä½¿ç”¨**ã€‚è¯¥æ¨¡å¼ä¸‹çš„å†…éƒ¨å†³ç­–ä½¿ç”¨äº†å›ºå®šçš„ã€é¢„è®¾å¥½çš„å‚æ•°æ¥å¹³è¡¡æ¢ç´¢æ•ˆç‡å’Œè®¡ç®—å¼€é”€ã€‚</p>
            </div>
        </main>
    </div>

<script>

class Renderer {
    constructor(canvas) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.cellSize = 15; this.colors = { FREE: "#f8fff8", OBSTACLE: "#3C3C3C", UNKNOWN: "#e0e0e0", START: "#32CD32", GOAL: "#FFA500", ROBOT: "#FF4500", PATH: "#1E90FF", ASTAR_PATH: "#FF4500", FRONTIER: "#DAA520", ANT_PATHS: ["#8A2BE2", "#00CED1", "#FFD700", "#FF69B4", "#7FFF00"], PHEROMONE_BASE: [40, 40, 220] }; }
    resize(width, height) { if (!this.canvas) return; this.canvas.width = width * this.cellSize; this.canvas.height = height * this.cellSize; }
    drawGrid(grid, typeMap) { if (!this.ctx || !grid) return; this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); grid.forEach((row, r) => { row.forEach((cell, c) => { this.ctx.fillStyle = this.colors[typeMap[cell]]; this.ctx.fillRect(c * this.cellSize, r * this.cellSize, this.cellSize, this.cellSize); }); }); }
    drawPheromones(pheromoneMap, grid) { if (!pheromoneMap || !grid || !this.ctx) return; const flatPheromones = pheromoneMap.flat().filter(p => p !== null && isFinite(p)); if (flatPheromones.length === 0) return; const maxPheromone = Math.max(...flatPheromones); if (maxPheromone <= 0.011) return; const base = this.colors.PHEROMONE_BASE; pheromoneMap.forEach((row, r) => { row.forEach((pher, c) => { if (grid[r][c] !== 2 && pher > 0.011) { const norm = Math.min(pher / maxPheromone, 1.0); const alpha = 0.05 + Math.pow(norm, 2) * 0.7; this.ctx.fillStyle = `rgba(${base[0]}, ${base[1]}, ${100 + norm * 155}, ${alpha})`; this.ctx.fillRect(c * this.cellSize, r * this.cellSize, this.cellSize, this.cellSize); } }); }); }
    drawPath(path, colorKey, lineWidth = 1, lineDash = []) { if (!path || !Array.isArray(path) || path.length < 2 || !this.ctx) return; const ctx = this.ctx; ctx.strokeStyle = this.colors[colorKey] || "#000000"; ctx.lineWidth = Math.max(1.5, lineWidth * (this.cellSize / 10)); ctx.setLineDash(lineDash); ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.beginPath(); ctx.moveTo((path[0][1] + 0.5) * this.cellSize, (path[0][0] + 0.5) * this.cellSize); for (let i = 1; i < path.length; i++) { ctx.lineTo((path[i][1] + 0.5) * this.cellSize, (path[i][0] + 0.5) * this.cellSize); } ctx.stroke(); ctx.setLineDash([]); }
    drawCircle(pos, colorKey) { if (!pos || !Array.isArray(pos) || !this.ctx) return; const [r, c] = pos; this.ctx.fillStyle = this.colors[colorKey]; this.ctx.beginPath(); this.ctx.arc((c + 0.5) * this.cellSize, (r + 0.5) * this.cellSize, this.cellSize * 0.4, 0, 2 * Math.PI); this.ctx.fill(); }
    render(frameData) { if (frameData.mode === 'planning') { this.drawGrid(frameData.grid, { 1: 'FREE', 2: 'OBSTACLE' }); if (frameData.pheromone_map) this.drawPheromones(frameData.pheromone_map, frameData.grid); if (frameData.ant_paths) frameData.ant_paths.forEach((p, i) => this.drawPath(p, this.colors.ANT_PATHS[i % this.colors.ANT_PATHS.length], 1)); this.drawCircle(frameData.start_pos, 'START'); this.drawCircle(frameData.goal_pos, 'GOAL'); if (frameData.final_path) { const pathColor = frameData.algorithm === 'aco' ? 'PATH' : 'ASTAR_PATH'; this.drawPath(frameData.final_path, pathColor, 3, frameData.algorithm === 'astar' ? [5, 5] : []); } } else if (frameData.mode === 'exploration') { this.drawGrid(frameData.known_grid, { 0: 'UNKNOWN', 1: 'FREE', 2: 'OBSTACLE' }); if (frameData.frontiers) frameData.frontiers.forEach(f => this.drawCircle(f, 'FRONTIER')); if (frameData.path_to_target) this.drawPath(frameData.path_to_target, 'PATH', 2); this.drawCircle(frameData.robot_pos, 'ROBOT'); } }
}
class App {
    constructor() { this.elements = {}; this.cacheDOMElements(); this.renderer = new Renderer(this.elements.mainCanvas); this.state = {}; this.resetState(); this.socket = null; this.drawingCtx = this.elements.drawingCanvas.getContext('2d'); this.drawnGrid = null; this.isDrawing = false; this.init(); }
    resetState(isFullReset = true) { const mode = isFullReset ? 'path_planning' : this.state.currentMode; this.state = { isSimulating: false, currentMode: mode, grid: null, width: 0, height: 0, startPos: null, goalPos: null, knownGrid: null, robotPos: null }; this.updateInfo("N/A"); }
    cacheDOMElements() { const ids = ["mode-switch", "map-source", "generate-map-panel", "draw-map-panel", "path-planning-params", "exploration-params", "run-simulation-btn", "generate-map-btn", "confirm-draw-btn", "clear-canvas-btn", "main-canvas", "drawing-canvas", "status-text", "info-text", "stat1-label", "stat2-label", "map-type", "obstacle-perc-group", "visualizer-tab", "explanation-tab", "visualizer-container"]; ids.forEach(id => this.elements[id.replace(/-(\w)/g, (_, g) => g.toUpperCase())] = document.getElementById(id)); }
    init() { this.initEventListeners(); this.updateUIVisibility(); this.connect(); }
    connect() { const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'; this.socket = new WebSocket(`${protocol}//${window.location.host}/ws`); this.socket.onopen = () => { this.updateStatus("è¿æ¥æˆåŠŸï¼", "info"); this.generateMap(); }; this.socket.onmessage = (event) => this.handleSocketMessage(JSON.parse(event.data)); this.socket.onclose = () => { this.updateStatus("è¿æ¥å·²æ–­å¼€", "error"); this.setAllControls(true, true); }; this.socket.onerror = (e) => { console.error("WebSocket Error:", e); this.updateStatus("è¿æ¥å¤±è´¥ï¼è¯·æ£€æŸ¥åç«¯æ˜¯å¦è¿è¡Œã€‚", "error"); }; }
    
    initEventListeners() {
        this.elements.modeSwitch.onchange = () => { this.updateUIVisibility(); this.generateMap(); };
        this.elements.mapSource.onchange = () => { this.updateUIVisibility(); if (this.elements.mapSource.value === 'generate') { this.generateMap(); } };
        this.elements.mapType.onchange = () => this.generateMap();
        this.elements.generateMapBtn.onclick = () => this.generateMap();
        this.elements.runSimulationBtn.onclick = () => this.runSimulation();
        this.elements.confirmDrawBtn.onclick = () => this.confirmDrawnMap();
        this.elements.clearCanvasBtn.onclick = () => this.clearDrawingCanvas();
        document.querySelectorAll('input[type="range"]').forEach(slider => { const valueSpan = document.getElementById(slider.id + '-val'); if (valueSpan) { valueSpan.textContent = slider.value; slider.addEventListener('input', () => { valueSpan.textContent = slider.value; if ((slider.id === 'map-width' || slider.id === 'map-height')) { this.setupDrawingCanvas(); } }); } });
        const canvas = this.elements.drawingCanvas;
        canvas.onmousedown = (e) => { this.isDrawing = true; this.drawOnCanvas(e); }; canvas.onmouseup = () => { this.isDrawing = false; }; canvas.onmouseleave = () => { this.isDrawing = false; }; canvas.onmousemove = (e) => this.drawOnCanvas(e);
    }
    
    updateUIVisibility() {
        this.state.currentMode = this.elements.modeSwitch.value; 
        const isExploration = this.state.currentMode === 'exploration';
        const drawOption = this.elements.mapSource.querySelector('option[value="draw"]');
        if (drawOption) { drawOption.disabled = !isExploration; }
        if (!isExploration && this.elements.mapSource.value === 'draw') { this.elements.mapSource.value = 'generate'; }
        const useDrawing = this.elements.mapSource.value === 'draw';
        const isDeceptive = this.elements.mapType.value === 'deceptive_hallway';
        this.elements.pathPlanningParams.classList.toggle('hidden', isExploration);
        this.elements.explorationParams.classList.toggle('hidden', !isExploration);
        document.getElementById('use-elitist').disabled = isExploration;
        this.elements.stat2Label.textContent = isExploration ? "æ¢ç´¢è¿›åº¦ / æ­¥æ•°" : "è·¯å¾„é•¿åº¦ / è¿­ä»£";
        this.elements.generateMapPanel.classList.toggle('hidden', useDrawing);
        this.elements.drawMapPanel.classList.toggle('hidden', !useDrawing);
        this.elements.obstaclePercGroup.classList.toggle('hidden', isDeceptive || useDrawing); 
        if (useDrawing && !this.drawnGrid) this.setupDrawingCanvas();
    }
    getParams() { const params = {}; const allParamIds = ["mode-switch", "map-width", "map-height", "map-type", "obstacle-perc", "n-ants-pp", "n-iterations-pp", "sensor-range", "n-ants-exp", "n-iterations-exp", "alpha", "beta", "evaporation", "use-elitist"]; allParamIds.forEach(id => { const el = document.getElementById(id); if (el) { params[id.replace(/-/g, '_')] = el.type === 'checkbox' ? el.checked : el.value; } }); return params; }
    setAllControls(isSimulating, disableAll = false) { this.state.isSimulating = isSimulating; const controls = document.querySelectorAll('.sidebar button, .sidebar select, .sidebar input'); controls.forEach(control => { control.disabled = isSimulating; }); if (disableAll) return; this.elements.runSimulationBtn.disabled = isSimulating || !this.state.grid; }
    sendMessage(data) { if (this.socket && this.socket.readyState === WebSocket.OPEN) { this.socket.send(JSON.stringify(data)); } else { this.updateStatus("æ— æ³•å‘é€æ¶ˆæ¯ï¼Œè¿æ¥å·²æ–­å¼€ã€‚", "error"); } }
    generateMap() { if (this.state.isSimulating) return; this.resetState(false); this.setAllControls(true); this.updateStatus("æ­£åœ¨ç”Ÿæˆåœ°å›¾...", "info"); this.sendMessage({ action: "generate_map", params: this.getParams() }); }
    runSimulation() { if (this.state.isSimulating || !this.state.grid) return; this.setAllControls(true); const params = this.getParams(); const action = this.state.currentMode === 'path_planning' ? "run_path_planning" : "run_exploration"; const payload = { action: action, params: { ...params, grid: this.state.grid, start_pos: this.state.startPos, goal_pos: this.state.goalPos } }; this.updateStatus("æ¨¡æ‹Ÿè¿è¡Œä¸­...", "info"); this.sendMessage(payload); }
    handleSocketMessage(data) { try { switch (data.type) {
        case "map_generated": this.state.grid = data.grid; this.state.width = data.width; this.state.height = data.height; this.state.startPos = data.start_pos; this.state.goalPos = data.goal_pos; this.state.robotPos = data.start_pos; this.drawInitialMap(); this.updateStatus("åœ°å›¾å·²å°±ç»ª", "info"); this.setAllControls(false); break;
        case "planning_update": this.renderer.render({ mode: 'planning', grid: this.state.grid, start_pos: this.state.startPos, goal_pos: this.state.goalPos, pheromone_map: data.pheromone_map, ant_paths: data.ant_paths }); this.updateStatus(`è¿­ä»£ä¸­: ${data.iteration}/${data.total_iterations}`); this.updateInfo(`${data.iteration} / ${data.total_iterations}`); break;
        case "planning_end": this.renderer.render({ mode: 'planning', grid: this.state.grid, start_pos: this.state.startPos, goal_pos: this.state.goalPos, pheromone_map: data.pheromone_map, final_path: data.path, algorithm: data.algorithm }); this.updateStatus(`æ‰¾åˆ°è·¯å¾„ (${(data.algorithm || 'aco').toUpperCase()})!`, "info"); this.updateInfo(`é•¿åº¦: ${data.path ? data.path.length - 1 : 'æ— '}`); this.setAllControls(false); break;
        case "exploration_update": this.state.knownGrid = data.known_grid; this.state.robotPos = data.robot_pos; this.state.steps = data.steps; this.state.explorationProgress = data.progress; this.renderer.render({ mode: 'exploration', known_grid: this.state.knownGrid, robot_pos: this.state.robotPos, frontiers: data.frontiers }); this.updateStatus(`æ¢ç´¢ä¸­...`); this.updateInfo(`${this.state.explorationProgress.toFixed(1)}% | ${this.state.steps} æ­¥`); break;
        case "robot_move": this.state.robotPos = data.pos; this.state.knownGrid = data.known_grid; this.state.steps = data.steps; this.renderer.render({ mode: 'exploration', known_grid: this.state.knownGrid, robot_pos: this.state.robotPos, path_to_target: data.path_to_target }); this.updateInfo(`${this.state.explorationProgress.toFixed(1)}% | ${this.state.steps} æ­¥`); break;
        case "exploration_end": this.state.knownGrid = data.known_grid; this.state.robotPos = data.robot_pos; this.renderer.render({ mode: 'exploration', known_grid: this.state.knownGrid, robot_pos: this.state.robotPos }); this.updateStatus(data.reason, "info"); this.updateInfo(`${data.progress.toFixed(1)}% | æ€»æ­¥æ•°: ${data.steps}`); this.setAllControls(false); break;
    } } catch (e) { console.error("å‰ç«¯å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™:", e, "\næ”¶åˆ°çš„æ•°æ®:", data); this.updateStatus("å‰ç«¯å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™ï¼", "error"); } }
    drawInitialMap() { if (!this.state.grid || !this.elements.visualizerContainer) return; this.renderer.cellSize = Math.max(5, Math.min(this.elements.visualizerContainer.clientWidth / this.state.width, this.elements.visualizerContainer.clientHeight / this.state.height) * 0.95); this.renderer.resize(this.state.width, this.state.height); if (this.state.currentMode === 'path_planning') { this.renderer.render({ mode: 'planning', grid: this.state.grid, start_pos: this.state.startPos, goal_pos: this.state.goalPos }); } else { this.state.knownGrid = Array(this.state.height).fill(0).map(() => Array(this.state.width).fill(0)); if (this.state.startPos) { this.state.knownGrid[this.state.startPos[0]][this.state.startPos[1]] = 1; } this.renderer.render({ mode: 'exploration', known_grid: this.state.knownGrid, robot_pos: this.state.startPos }); } }
    updateStatus(message, type = 'info') { this.elements.statusText.textContent = message; this.elements.statusText.className = `value ${type}`; }
    updateInfo(message) { this.elements.infoText.textContent = message; }
    setupDrawingCanvas() { const mapWidth = parseInt(document.getElementById('map-width').value); const mapHeight = parseInt(document.getElementById('map-height').value); this.drawnGrid = Array(mapHeight).fill(0).map(() => Array(mapWidth).fill(1)); const canvasEl = this.elements.drawingCanvas; const parentWidth = canvasEl.parentElement.clientWidth; canvasEl.width = parentWidth; canvasEl.height = Math.round(parentWidth * (mapHeight / mapWidth)); this.clearDrawingCanvas(true); }
    drawOnCanvas(event) { if (!this.isDrawing || !this.drawnGrid) return; const mapHeight = this.drawnGrid.length; const mapWidth = this.drawnGrid[0].length; const rect = this.elements.drawingCanvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const c = Math.floor((x / rect.width) * mapWidth); const r = Math.floor((y / rect.height) * mapHeight); if (r >= 0 && r < mapHeight && c >= 0 && c < mapWidth) { const newVal = event.shiftKey ? 1 : 2; if (this.drawnGrid[r][c] !== newVal) { this.drawnGrid[r][c] = newVal; this.redrawDrawingCanvas(); } } }
    redrawDrawingCanvas() { const mapHeight = this.drawnGrid.length; const mapWidth = this.drawnGrid[0].length; const cellWidthOnCanvas = this.elements.drawingCanvas.width / mapWidth; const cellHeightOnCanvas = this.elements.drawingCanvas.height / mapHeight; this.drawingCtx.fillStyle = '#FFFFFF'; this.drawingCtx.fillRect(0, 0, this.elements.drawingCanvas.width, this.elements.drawingCanvas.height); for (let r = 0; r < mapHeight; r++) { for (let c = 0; c < mapWidth; c++) { if (this.drawnGrid[r][c] === 2) { this.drawingCtx.fillStyle = '#3C3C3C'; this.drawingCtx.fillRect(c * cellWidthOnCanvas, r * cellHeightOnCanvas, cellWidthOnCanvas, cellHeightOnCanvas); } } } }
    clearDrawingCanvas(isSetup = false) { if (!isSetup) { this.setupDrawingCanvas(); return; } const mapHeight = this.drawnGrid.length; const mapWidth = this.drawnGrid[0].length; this.drawnGrid = Array(mapHeight).fill(0).map(() => Array(mapWidth).fill(1)); this.redrawDrawingCanvas(); }
    confirmDrawnMap() { if (this.state.isSimulating || !this.drawnGrid) return; this.resetState(false); this.setAllControls(true); this.updateStatus("åŠ è½½æ‰‹ç»˜åœ°å›¾...", "info"); this.sendMessage({ action: "from_drawing", params: { grid: this.drawnGrid, mode: this.state.currentMode } }); }
}
document.addEventListener('DOMContentLoaded', () => { window.app = new App(); });
</script>
</body>
</html>